<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SnowMon</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
    <link href="https://fonts.googleapis.com/css2?family=Jaini&family=IM+Fell+English&display=swap" rel="stylesheet" />
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        #overlayCanvas {
            pointer-events: none; /* Allow mouse events to pass through to main canvas */
            z-index: 1;
        }
        #glCanvas {
            z-index: 0;
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-backdrop.hidden {
            display: none;
        }

        .modal {
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            max-width: 1000px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 2px solid #e5e5e5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
            color: #1a1a1a;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 2rem;
            color: #1a1a1a;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: color 0.2s, background-color 0.2s;
        }

        .close-button:hover {
            background-color: #f5f5f5;
        }

        .modal-body {
            font-size: larger;
            padding: 1.5rem;
            color: #1a1a1a;
            line-height: 1.6;
        }

        .modal-body p {
            margin-bottom: 1rem;
        }

        .modal-body li {
            margin-bottom: 1rem;
        }

        .banner {
            background-image: url('https://siege.hackclub.com/assets/scroll-aca243bf.webp');
            background-position: center;
            background-size: 150%;
            border-left: 4px solid #3b2a1a;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .banner-logo {
            width: 64px;
            height: 64px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .banner-content {
            flex: 1;
        }

        .banner h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.8rem;
            font-weight: 600;
            font-family: 'Jaini', cursive;
            color: #3b2a1a;
        }

        .banner p {
            margin: 0;
            font-size: 1.2rem;
            font-family: 'IM Fell English', serif;
            color: #3b2a1a;
        }

        .banner a {
            color: #3b2a1a;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>

    <!-- Welcome Modal -->
    <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal">
            <div class="modal-header">
                <h2>Welcome to SnowMon!</h2>
                <button class="close-button" id="closeModalBtn" aria-label="Close">Ã—</button>
            </div>

            <div class="modal-body">
                <div class="banner">
                    <img src="https://siege.hackclub.com/assets/logo-55998110.webp" alt="Siege logo" class="banner-logo" />
                    <div class="banner-content">
                        <h3>Reviewing for Siege?</h3>
                        <p>Feel free to <a href="https://hackclub.slack.com/team/U074K2VPP62">message me on Slack</a> if you have any questions or issues :D</p>
                    </div>
                </div>

                <h2>About</h2>

                <p>
                    <b>SnowMon</b> is a silly little resource monitor which shows you the current RAM usage of the
                    server as a snowstorm.
                </p>

                <p>
                    It's built upon an <b>entirely custom HTTP server made from scratch</b>, which was written with
                    <b>zero AI assistance</b> and <b>zero libraries</b>. (Yes, that means freakishly parsing HTTP
                    headers - and even JSON - in Java regex!)
                </p>

                <h2>Try it out!</h2>

                <p>
                    For the purposes of this demo, I've put together <b>Ticket Chief</b>, a mock ticket purchase
                    platform with a queueing system for purchases, where each pending purchase takes up 512MB of RAM.
                    (Very realistic, I know)
                </p>

                <p>See it in action for yourself:</p>

                <ol>
                    <li>Open <a href="/ticketchief" target="_blank">/ticketchief</a> in a new tab</li>
                    <li>Drag the new tab side-by-side beside this one</li>
                    <li>Queue to purchase a ticket</li>
                    <li>Watch the blizzard intensify as you wait in the queue, then die down again afterwards!</li>
                    <li>You can even try getting multiple tabs/devices/friends to join the queue simultaneously!</li>
                </ol>

                <h2>Are you a huge nerd?</h2>

                <p>
                    I submitted the "HTTP server from scratch" part of this Siege project to my school as a coursework
                    submission as well, and as part of that, I wrote a detailed in-depth report about the inner workings
                    of the server and Ticket Chief.
                </p>

                <p>If you're curious, you can have a read of my report <a href="/report" target="_blank">here</a>!</p>
            </div>
        </div>
    </div>

    <script>
        // Modal functionality
        const modalBackdrop = document.getElementById('modalBackdrop');
        const closeModalBtn = document.getElementById('closeModalBtn');

        function closeModal() {
            modalBackdrop.classList.add('hidden');
        }

        function openModal() {
            modalBackdrop.classList.remove('hidden');
        }

        // Close on button click
        closeModalBtn.addEventListener('click', closeModal);

        // Close on backdrop click
        modalBackdrop.addEventListener('click', (event) => {
            if (event.target === modalBackdrop) {
                closeModal();
            }
        });

        // Close on Escape key
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && !modalBackdrop.classList.contains('hidden')) {
                closeModal();
            }
        });

        // Expose openModal globally
        window.openModal = openModal;

        // Vertex shader - simple pass-through shader that covers the entire screen
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader wrapper for ShaderToy shaders
        const fragmentShaderPrefix = `
            #ifdef GL_ES
            precision highp float;
            #endif

            #extension GL_OES_standard_derivatives : enable

            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec4 iMouse;
            uniform int iFrame;
            uniform vec2 uCoordOffset;  // Offset for CSS cover behaviour

            // ShaderToy mainImage function will be inserted here
        `;

        const fragmentShaderSuffix = `
            void main() {
                // Apply offset to achieve CSS cover behaviour (fill and crop)
                vec2 adjustedCoord = gl_FragCoord.xy + uCoordOffset;
                mainImage(gl_FragColor, adjustedCoord);
            }
        `;

        // Initialise WebGL
        async function init() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            // Enable required extensions
            const ext = gl.getExtension('OES_standard_derivatives');
            if (!ext) {
                console.warn('OES_standard_derivatives extension not available');
            }

            // Load the ShaderToy shader
            let shaderToyCode;
            try {
                const response = await fetch('shaders/overthemoon.frag');
                shaderToyCode = await response.text();
            } catch (error) {
                console.error('Failed to load shader:', error);
                return;
            }

            // Combine the shader parts
            const fragmentShaderSource = fragmentShaderPrefix + shaderToyCode + fragmentShaderSuffix;

            // Create and compile shaders
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            if (!vertexShader || !fragmentShader) {
                console.error('Failed to create shaders');
                return;
            }

            // Create shader programme
            const programme = gl.createProgram();
            gl.attachShader(programme, vertexShader);
            gl.attachShader(programme, fragmentShader);
            gl.linkProgram(programme);

            if (!gl.getProgramParameter(programme, gl.LINK_STATUS)) {
                console.error('Programme linking error:', gl.getProgramInfoLog(programme));
                return;
            }

            // Set up geometry (full-screen quad)
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(programme, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const uniformLocations = {
                iResolution: gl.getUniformLocation(programme, 'iResolution'),
                iTime: gl.getUniformLocation(programme, 'iTime'),
                iMouse: gl.getUniformLocation(programme, 'iMouse'),
                iFrame: gl.getUniformLocation(programme, 'iFrame'),
                uCoordOffset: gl.getUniformLocation(programme, 'uCoordOffset')
            };

            // Mouse tracking
            let mouseX = 0, mouseY = 0;
            let mousePressed = false;

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                // Scale mouse coordinates to canvas resolution
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                mouseX = (e.clientX - rect.left) * scaleX;
                mouseY = canvas.height - ((e.clientY - rect.top) * scaleY); // Flip Y coordinate
            });

            canvas.addEventListener('mousedown', () => mousePressed = true);
            canvas.addEventListener('mouseup', () => mousePressed = false);

            // Resize handler - fills entire screen
            function resize() {
                // Set canvas to fill the entire window
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Update WebGL viewport
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resize);
            resize();

            // Animation loop
            let startTime = Date.now();
            let frame = 0;

            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;

                gl.useProgram(programme);

                // Calculate virtual resolution for CSS "cover" behaviour
                // The shader content should fill the screen and crop overflow
                const targetAspect = 16.0 / 9.0;
                const canvasAspect = canvas.width / canvas.height;

                let virtualWidth, virtualHeight;
                let offsetX = 0, offsetY = 0;

                if (canvasAspect > targetAspect) {
                    // Canvas is wider than 16:9 - scale based on WIDTH, crop top/bottom
                    virtualWidth = canvas.width;
                    virtualHeight = canvas.width / targetAspect;
                    // Center vertically (content overflows equally top and bottom)
                    offsetY = (virtualHeight - canvas.height) / 2;
                } else {
                    // Canvas is taller than 16:9 - scale based on HEIGHT, crop left/right
                    virtualHeight = canvas.height;
                    virtualWidth = canvas.height * targetAspect;
                    // Center horizontally (content overflows equally left and right)
                    offsetX = (virtualWidth - canvas.width) / 2;
                }

                // Set uniforms
                gl.uniform2f(uniformLocations.iResolution, virtualWidth, virtualHeight);
                gl.uniform2f(uniformLocations.uCoordOffset, offsetX, offsetY);
                gl.uniform1f(uniformLocations.iTime, currentTime);
                gl.uniform4f(uniformLocations.iMouse, mouseX, mouseY, mousePressed ? 1.0 : 0.0, 0.0);
                gl.uniform1i(uniformLocations.iFrame, frame);

                // Draw
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                frame++;
                requestAnimationFrame(render);
            }

            render();
        }

        // Blizzard overlay settings
        const blizzardSettings = {
            snowflakeAmount: 150,
            blizzardFactor: 0,
            _targetBlizzardFactor: 0,
            lerpSpeed: 0.02,  // How fast to interpolate (0-1, higher = faster)
            blizzardTime: 0,  // Accumulated time for snowflake movement (prevents jumps)
            lastFrameTime: null  // For delta time calculation
        };

        // Setter for blizzardFactor that sets the target instead
        Object.defineProperty(blizzardSettings, 'targetBlizzardFactor', {
            set: function(value) {
                this._targetBlizzardFactor = value;
            },
            get: function() {
                return this._targetBlizzardFactor;
            }
        });

        // Interpolation function - call this each frame
        function updateBlizzardInterpolation() {
            const diff = blizzardSettings._targetBlizzardFactor - blizzardSettings.blizzardFactor;
            if (Math.abs(diff) > 0.001) {
                blizzardSettings.blizzardFactor += diff * blizzardSettings.lerpSpeed;
            } else {
                blizzardSettings.blizzardFactor = blizzardSettings._targetBlizzardFactor;
            }
        }

        // Expose settings globally for easy control
        window.blizzardSettings = blizzardSettings;

        // Blizzard overlay shader with uniforms
        const blizzardFragmentShader = `
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform vec2 iResolution;
            uniform vec2 uCoordOffset;
            uniform float iTime;
            uniform float uSnowflakeAmount;
            uniform float uBlizzardFactor;
            uniform float uBlizzardTime;  // Pre-accumulated time to prevent jumps

            vec2 uv;

            float rnd(float x)
            {
                return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));
            }

            float drawCircle(vec2 center, float radius)
            {
                return 1.0 - smoothstep(0.0, radius, length(uv - center));
            }

            void main()
            {
                // Apply offset for CSS cover behaviour
                vec2 adjustedCoord = gl_FragCoord.xy + uCoordOffset;
                uv = adjustedCoord / iResolution.x;

                float j;
                int snowflakeCount = int(uSnowflakeAmount);

                for(int i = 0; i < 1000; i++)
                {
                    if(i >= snowflakeCount) break;

                    j = float(i);
                    float speed = 0.3+rnd(cos(j))*(0.7+0.5*cos(j/(uSnowflakeAmount*0.25)));
                    // Use pre-accumulated blizzardTime instead of iTime*factor to prevent jumps
                    vec2 center = vec2((0.25-uv.y)*(uBlizzardFactor*.5)+rnd(j)+0.1*cos(iTime+sin(j)), mod(sin(j)-speed*uBlizzardTime*1.5, 0.65));

                    // Draw white snowflakes with transparency
                    float circle = drawCircle(center, 0.001+speed*0.012);
                    gl_FragColor += vec4(0.9, 0.95, 1.0, circle * 0.5);
                }
            }
        `;

        // Initialise blizzard overlay
        async function initBlizzard() {
            const canvas = document.getElementById('overlayCanvas');
            const gl = canvas.getContext('webgl', {
                alpha: true,
                premultipliedAlpha: true
            }) || canvas.getContext('experimental-webgl', {
                alpha: true,
                premultipliedAlpha: false
            });

            if (!gl) {
                console.error('WebGL not supported for overlay');
                return;
            }

            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Create and compile shaders
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Blizzard shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, blizzardFragmentShader);

            if (!vertexShader || !fragmentShader) {
                console.error('Failed to create blizzard shaders');
                return;
            }

            // Create shader programme
            const programme = gl.createProgram();
            gl.attachShader(programme, vertexShader);
            gl.attachShader(programme, fragmentShader);
            gl.linkProgram(programme);

            if (!gl.getProgramParameter(programme, gl.LINK_STATUS)) {
                console.error('Blizzard programme linking error:', gl.getProgramInfoLog(programme));
                return;
            }

            // Set up geometry (full-screen quad)
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(programme, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const uniformLocations = {
                iResolution: gl.getUniformLocation(programme, 'iResolution'),
                uCoordOffset: gl.getUniformLocation(programme, 'uCoordOffset'),
                iTime: gl.getUniformLocation(programme, 'iTime'),
                uSnowflakeAmount: gl.getUniformLocation(programme, 'uSnowflakeAmount'),
                uBlizzardFactor: gl.getUniformLocation(programme, 'uBlizzardFactor'),
                uBlizzardTime: gl.getUniformLocation(programme, 'uBlizzardTime')
            };

            // Resize handler
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resize);
            resize();

            // Animation loop
            let startTime = Date.now();

            function render() {
                const now = Date.now();
                const currentTime = (now - startTime) / 1000.0;

                // Calculate delta time for blizzard time accumulation
                if (blizzardSettings.lastFrameTime === null) {
                    blizzardSettings.lastFrameTime = now;
                }
                const deltaTime = (now - blizzardSettings.lastFrameTime) / 1000.0;
                blizzardSettings.lastFrameTime = now;

                // Smoothly interpolate blizzard factor towards target
                updateBlizzardInterpolation();

                // Accumulate blizzard time based on current factor
                // This prevents snowflake position jumps when factor changes
                blizzardSettings.blizzardTime += deltaTime * (0.1 + blizzardSettings.blizzardFactor);

                gl.useProgram(programme);

                // Calculate virtual resolution for CSS "cover" behaviour
                const targetAspect = 16.0 / 9.0;
                const canvasAspect = canvas.width / canvas.height;

                let virtualWidth, virtualHeight;
                let offsetX = 0, offsetY = 0;

                if (canvasAspect > targetAspect) {
                    // Canvas is wider than 16:9 - scale based on WIDTH
                    virtualWidth = canvas.width;
                    virtualHeight = canvas.width / targetAspect;
                    offsetY = (virtualHeight - canvas.height) / 2;
                } else {
                    // Canvas is taller than 16:9 - scale based on HEIGHT
                    virtualHeight = canvas.height;
                    virtualWidth = canvas.height * targetAspect;
                    offsetX = (virtualWidth - canvas.width) / 2;
                }

                // Set uniforms
                gl.uniform2f(uniformLocations.iResolution, virtualWidth, virtualHeight);
                gl.uniform2f(uniformLocations.uCoordOffset, offsetX, offsetY);
                gl.uniform1f(uniformLocations.iTime, currentTime);
                gl.uniform1f(uniformLocations.uSnowflakeAmount, blizzardSettings.snowflakeAmount);
                gl.uniform1f(uniformLocations.uBlizzardFactor, blizzardSettings.blizzardFactor);
                gl.uniform1f(uniformLocations.uBlizzardTime, blizzardSettings.blizzardTime);

                // Clear with transparent background
                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            render();
        }

        // Start when DOM is loaded
        window.addEventListener('DOMContentLoaded', () => {
            init();
            initBlizzard();
            fetch('/snowmon').then(response => response.json().then(data => {
                blizzardSettings.blizzardFactor = data['memoryUsage'];
                blizzardSettings._targetBlizzardFactor = data['memoryUsage'];
            }));
            setInterval(async () => {
                const response = await fetch('/snowmon');
                const data = await response.json();
                // Set target for smooth interpolation
                blizzardSettings.targetBlizzardFactor = data['memoryUsage'];
            }, 3000);
        });
    </script>
</body>
</html>