<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SnowMon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        #overlayCanvas {
            pointer-events: none; /* Allow mouse events to pass through to main canvas */
            z-index: 1;
        }
        #glCanvas {
            z-index: 0;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>

    <script>
        // Vertex shader - simple pass-through shader that covers the entire screen
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader wrapper for ShaderToy shaders
        const fragmentShaderPrefix = `
            #ifdef GL_ES
            precision highp float;
            #endif

            #extension GL_OES_standard_derivatives : enable

            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec4 iMouse;
            uniform int iFrame;

            // ShaderToy mainImage function will be inserted here
        `;

        const fragmentShaderSuffix = `
            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        // Initialise WebGL
        async function init() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            // Enable required extensions
            const ext = gl.getExtension('OES_standard_derivatives');
            if (!ext) {
                console.warn('OES_standard_derivatives extension not available');
            }

            // Load the ShaderToy shader
            let shaderToyCode;
            try {
                const response = await fetch('shaders/overthemoon.frag');
                shaderToyCode = await response.text();
            } catch (error) {
                console.error('Failed to load shader:', error);
                return;
            }

            // Combine the shader parts
            const fragmentShaderSource = fragmentShaderPrefix + shaderToyCode + fragmentShaderSuffix;

            // Create and compile shaders
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            if (!vertexShader || !fragmentShader) {
                console.error('Failed to create shaders');
                return;
            }

            // Create shader programme
            const programme = gl.createProgram();
            gl.attachShader(programme, vertexShader);
            gl.attachShader(programme, fragmentShader);
            gl.linkProgram(programme);

            if (!gl.getProgramParameter(programme, gl.LINK_STATUS)) {
                console.error('Programme linking error:', gl.getProgramInfoLog(programme));
                return;
            }

            // Set up geometry (full-screen quad)
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(programme, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const uniformLocations = {
                iResolution: gl.getUniformLocation(programme, 'iResolution'),
                iTime: gl.getUniformLocation(programme, 'iTime'),
                iMouse: gl.getUniformLocation(programme, 'iMouse'),
                iFrame: gl.getUniformLocation(programme, 'iFrame')
            };

            // Mouse tracking
            let mouseX = 0, mouseY = 0;
            let mousePressed = false;

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                // Scale mouse coordinates to canvas resolution
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                mouseX = (e.clientX - rect.left) * scaleX;
                mouseY = canvas.height - ((e.clientY - rect.top) * scaleY); // Flip Y coordinate
            });

            canvas.addEventListener('mousedown', () => mousePressed = true);
            canvas.addEventListener('mouseup', () => mousePressed = false);

            // Resize handler - fills entire screen
            function resize() {
                // Set canvas to fill the entire window
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Update WebGL viewport
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resize);
            resize();

            // Animation loop
            let startTime = Date.now();
            let frame = 0;

            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;

                gl.useProgram(programme);

                // Calculate virtual resolution that maintains 16:9 aspect ratio
                const targetAspect = 16.0 / 9.0;
                const canvasAspect = canvas.width / canvas.height;

                let virtualWidth, virtualHeight;
                if (canvasAspect > targetAspect) {
                    // Canvas is wider - use full height, adjust width
                    virtualHeight = canvas.height;
                    virtualWidth = virtualHeight * targetAspect;
                } else {
                    // Canvas is taller - use full width, adjust height
                    virtualWidth = canvas.width;
                    virtualHeight = virtualWidth / targetAspect;
                }

                // Set uniforms - pass virtual resolution instead of actual canvas size
                gl.uniform2f(uniformLocations.iResolution, virtualWidth, virtualHeight);
                gl.uniform1f(uniformLocations.iTime, currentTime);
                gl.uniform4f(uniformLocations.iMouse, mouseX, mouseY, mousePressed ? 1.0 : 0.0, 0.0);
                gl.uniform1i(uniformLocations.iFrame, frame);

                // Draw
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                frame++;
                requestAnimationFrame(render);
            }

            render();
        }

        // Blizzard overlay settings
        const blizzardSettings = {
            snowflakeAmount: 150,
            blizzardFactor: 0,
            _targetBlizzardFactor: 0,
            lerpSpeed: 0.02  // How fast to interpolate (0-1, higher = faster)
        };

        // Setter for blizzardFactor that sets the target instead
        Object.defineProperty(blizzardSettings, 'targetBlizzardFactor', {
            set: function(value) {
                this._targetBlizzardFactor = value;
            },
            get: function() {
                return this._targetBlizzardFactor;
            }
        });

        // Interpolation function - call this each frame
        function updateBlizzardInterpolation() {
            const diff = blizzardSettings._targetBlizzardFactor - blizzardSettings.blizzardFactor;
            if (Math.abs(diff) > 0.001) {
                blizzardSettings.blizzardFactor += diff * blizzardSettings.lerpSpeed;
            } else {
                blizzardSettings.blizzardFactor = blizzardSettings._targetBlizzardFactor;
            }
        }

        // Expose settings globally for easy control
        window.blizzardSettings = blizzardSettings;

        // Blizzard overlay shader with uniforms
        const blizzardFragmentShader = `
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform vec2 iResolution;
            uniform float iTime;
            uniform float uSnowflakeAmount;
            uniform float uBlizzardFactor;

            vec2 uv;

            float rnd(float x)
            {
                return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));
            }

            float drawCircle(vec2 center, float radius)
            {
                return 1.0 - smoothstep(0.0, radius, length(uv - center));
            }

            void main()
            {
                uv = gl_FragCoord.xy / iResolution.x;

                float j;
                int snowflakeCount = int(uSnowflakeAmount);

                for(int i = 0; i < 1000; i++)
                {
                    if(i >= snowflakeCount) break;

                    j = float(i);
                    float speed = 0.3+rnd(cos(j))*(0.7+0.5*cos(j/(uSnowflakeAmount*0.25)));
                    vec2 center = vec2((0.25-uv.y)*(uBlizzardFactor*.5)+rnd(j)+0.1*cos(iTime+sin(j)), mod(sin(j)-speed*(iTime*1.5*(0.1+uBlizzardFactor)), 0.65));

                    // Draw white snowflakes with transparency
                    float circle = drawCircle(center, 0.001+speed*0.012);
                    gl_FragColor += vec4(0.9, 0.95, 1.0, circle * 0.5);
                }
            }
        `;

        // Initialise blizzard overlay
        async function initBlizzard() {
            const canvas = document.getElementById('overlayCanvas');
            const gl = canvas.getContext('webgl', {
                alpha: true,
                premultipliedAlpha: true
            }) || canvas.getContext('experimental-webgl', {
                alpha: true,
                premultipliedAlpha: false
            });

            if (!gl) {
                console.error('WebGL not supported for overlay');
                return;
            }

            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Create and compile shaders
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Blizzard shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, blizzardFragmentShader);

            if (!vertexShader || !fragmentShader) {
                console.error('Failed to create blizzard shaders');
                return;
            }

            // Create shader programme
            const programme = gl.createProgram();
            gl.attachShader(programme, vertexShader);
            gl.attachShader(programme, fragmentShader);
            gl.linkProgram(programme);

            if (!gl.getProgramParameter(programme, gl.LINK_STATUS)) {
                console.error('Blizzard programme linking error:', gl.getProgramInfoLog(programme));
                return;
            }

            // Set up geometry (full-screen quad)
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(programme, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const uniformLocations = {
                iResolution: gl.getUniformLocation(programme, 'iResolution'),
                iTime: gl.getUniformLocation(programme, 'iTime'),
                uSnowflakeAmount: gl.getUniformLocation(programme, 'uSnowflakeAmount'),
                uBlizzardFactor: gl.getUniformLocation(programme, 'uBlizzardFactor')
            };

            // Resize handler
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resize);
            resize();

            // Animation loop
            let startTime = Date.now();

            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;

                // Smoothly interpolate blizzard factor towards target
                updateBlizzardInterpolation();

                gl.useProgram(programme);

                // Set uniforms
                gl.uniform2f(uniformLocations.iResolution, canvas.width, canvas.height);
                gl.uniform1f(uniformLocations.iTime, currentTime);
                gl.uniform1f(uniformLocations.uSnowflakeAmount, blizzardSettings.snowflakeAmount);
                gl.uniform1f(uniformLocations.uBlizzardFactor, blizzardSettings.blizzardFactor);

                // Clear with transparent background
                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            render();
        }

        // Start when DOM is loaded
        window.addEventListener('DOMContentLoaded', () => {
            init();
            initBlizzard();
            setInterval(async () => {
                const response = await fetch('/snowmon');
                const data = await response.json();
                // Set target for smooth interpolation
                blizzardSettings.targetBlizzardFactor = data['memoryUsage'];
            }, 3000);
        });
    </script>
</body>
</html>